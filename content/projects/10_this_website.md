[creationTime]:- "Feb 13. 2023"
[lastWriteTime]:- "Feb 13. 2023"

# This Website

<a href="https://github.com/aMOPel/nim-karax-website/tree/amopels_content">
<img src="assets/icons8-github.svg" alt="GitHub" class="inline m-1 dark:invert">
GitHub</a>

This very website 
is a SPA (single page application) using transpiled Markdown as a source of content.

It was build 
using [Nim](https://nim-lang.org/), [Karax](https://github.com/karaxnim/karax) and [TailwindCSS](https://tailwindcss.com/).

## Architecture

### Functionality and Layout

Among other things, Karax provides a DSL in Nim to describe HTML.
This allows for describing the HTML layout intermingled with the imperative code.
A concept somewhat similar to Vue's concepts of template syntax, conditional rendering etc.
Only in Vue it's about inserting functionality into HTML,
but in Karax it's about generating HTML using a programming language.

The Nim code can be compiled to a SPA JavaScript file, which renders the whole website.

The static HTML file, that the SPA JavaScript file is embedded in,
is also generated using Nim.
This enables imperative composition of all metadata, 
(external) stylesheets and scripts that may be put anywhere in the static HTML.

### Styles

On top of that, the Tailwind utility classes can be written directly into the
Karax HTML tags.
Tailwind is not strictly necessary to apply style directly to the tags,
since the tags also have a mutable `style` attribute, however Tailwind makes the
application of the styles a little simpler.

**Bonus:** Since the Tailwind classes are just strings in Nim,
they can be composed in any way desired, using string manipulation.

### Fusion Of Concerns?

This project structure is quite interesting, as every aspect of the 
website can be described in Nim and manipulated using it.

The different parts of the website can be split up into reusable components 
(which are just functions in this case) and separated into modules,
also similar to Vue.

This structure is the antithesis to the often advertised 
"separation of concerns". Instead of ordering Code by concerns 
(layout, style, functionality), it can be ordered by components, in which
the concerns are mixed and matched as needed.

Example:

*The menu component with collapsed Tailwind classes:*
```nim
proc buildMenu*(menu: openArray[MenuItem]): VNode =
  if clientWidth() < mobileMenuWidthThreshold:
    result = buildMobileMenu(menu) # different component
  else:
    result = buildHtml(nav(class="...")):
      ul(class="..."):
        for (t, href) in menu:
          li(class="..."):
            a(class="...", href=kstring("#/" & href)):
              text t
```

### Content Management

Also notable, is the content management.

Using a Markdown-To-HTML Converter and a HTML-To-KaraxDSL Converter,
Markdown files get transpiled to the Karax DSL.
That Nim code can then be imported and integrated into the website
as desired. 

For example, this website is using the file names of the Markdown 
files as routes for which the content of the body will be the content of the 
Markdown file. 

E.g. for this article the route is `/this_website` so its content
is generated from a Markdown file named `this_website.md`.

## Build Process

A Nim build script takes care of 
1. transpiling the content to KaraxDSL,
2. compiling the Karax website to JavaScript,
3. generating the static HTML from Nim code and
4. placing all those and the assets in the `build/` directory

This can either be once,
or continuously, using my file watcher [nosey.nim](#/nosey_nim).

Additionally the `styles.css` needs to be generated by the Tailwind CLI.

When deploying, another script is used to minify all the files in the `build/`
directory, using `uglify-js`, `cssnano`, `html-minifier` and `imagemin`.
The minified files are then placed in the `dist/` directory.

## Features

### Syntax Highlighting

Ordinarily it's not a big deal to throw in a `highlight.js` import in the head of the HTML.
However with SPAs it's not that simple, since the HTML doesn't get sent anew by 
the server but is mutated on client-side.
Thus `highlight.js` needs to be invoked on every redraw to update the code block
classes.
Luckily Nim's excellent FFI (foreign function interface) makes it quite easy to 
invoke external JavaScript functions, while staying in Nim.

```nim
# using ffi to invoke external js code
proc highlight(elem: Element) {.importjs: "hljs.highlightElement(#)".}

# the post render callback
proc postRender(routerDate: RouterData) =
  for elem in document.querySelectorAll("pre code"):
    highlight(elem)
```

### Dark Mode

Using Tailwinds `dark:` variant it's effortless to change styles, based on 
`prefers-color-scheme`.
This website uses a simple color palette and simply swaps light and dark 
colors for dark mode. Additionally the black icons get inverted.

However, to accommodate 2 different `highlight.js` themes, it was necessary to use
some code again.

```nim
proc darkMode(): bool {.importjs: "window.matchMedia('(prefers-color-scheme: dark)').matches".}

proc replaceHeadLink(href: string) =
  # swaps out one stylesheet link for another

proc postRender(routerDate: RouterData) =
  if darkMode(): replaceHeadLink(hljsDarkTheme)
  else: replaceHeadLink(hljsLightTheme)
```

### Responsive Design

With Tailwinds `md:` variant, styles can easily be changed,
based on the client screen's `min-width`.
That took care of most responsiveness issues.

Additionally, for mobile, this website uses a special menu, which is turned on 
and off based on `clientWidth`, as could be seen in the very first example.

